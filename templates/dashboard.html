<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Webhook Dashboard | TechStaX</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ðŸš€ GitHub Webhook Events</h1>
        <p class="subtitle">Real-time repository activity monitor</p>
        <div class="status">
          <span class="status-indicator" id="status-indicator"></span>
          <span id="status-text">Connecting...</span>
          <span class="last-updated" id="last-updated"></span>
        </div>
      </header>

      <main>
        <div class="events-container" id="events-container">
          <div class="empty-state" id="empty-state">
            <p>Waiting for events...</p>
            <p class="hint">
              Trigger a push or pull request in your action-repo to see activity
              here.
            </p>
          </div>
          <ul class="events-list" id="events-list" style="display: none"></ul>
        </div>
      </main>

      <footer>
        <p>TechStaX Assignment | Auto-refresh every 15 seconds</p>
      </footer>
    </div>

    <script>
      // Configuration
      const POLL_INTERVAL = 15000; // 15 seconds
      const API_ENDPOINT = "/api/events";

      // State
      let lastSeenTimestamp = null;
      let displayedEventIds = new Set();
      let pollTimer = null;

      // DOM Elements
      const eventsList = document.getElementById("events-list");
      const emptyState = document.getElementById("empty-state");
      const statusIndicator = document.getElementById("status-indicator");
      const statusText = document.getElementById("status-text");
      const lastUpdated = document.getElementById("last-updated");

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        fetchEvents(); // Initial fetch
        startPolling();
      });

      function startPolling() {
        pollTimer = setInterval(fetchEvents, POLL_INTERVAL);
      }

      function stopPolling() {
        if (pollTimer) {
          clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchEvents() {
        try {
          updateStatus("loading");

          let url = API_ENDPOINT;
          if (lastSeenTimestamp) {
            url += `?last_seen=${encodeURIComponent(lastSeenTimestamp)}`;
          }

          const response = await fetch(url);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          if (data.events && data.events.length > 0) {
            // Update last seen timestamp to the most recent event
            const newestEvent = data.events[0]; // Already sorted desc
            lastSeenTimestamp = newestEvent.timestamp;

            // Filter out already displayed events
            const newEvents = data.events.filter(
              (e) => !displayedEventIds.has(e.id),
            );

            if (newEvents.length > 0) {
              renderEvents(newEvents, true); // prepend new events
            }
          }

          updateStatus("connected", data.count);
        } catch (error) {
          console.error("Fetch error:", error);
          updateStatus("error");
        }
      }

      // function renderEvents(events, prepend = false) {
      //   // Hide empty state if we have events
      //   if (events.length > 0) {
      //     emptyState.style.display = "none";
      //     eventsList.style.display = "block";
      //   }

      //   events.forEach((event) => {
      //     // Skip if already displayed
      //     if (displayedEventIds.has(event.id)) {
      //       return;
      //     }
      //     displayedEventIds.add(event.id);

      //     const li = document.createElement("li");
      //     li.className = `event-item event-${event.action.toLowerCase()}`;
      //     li.dataset.id = event.id;

      //     const icon = getEventIcon(event.action);

      //     li.innerHTML = `
      //               <div class="event-icon">${icon}</div>
      //               <div class="event-content">
      //                   <p class="event-message">${escapeHtml(event.message)}</p>
      //                   <div class="event-meta">
      //                       <span class="event-type">${event.action}</span>
      //                       <span class="event-time">${formatTime(event.timestamp)}</span>
      //                       <span class="event-id">#${event.request_id}</span>
      //                   </div>
      //               </div>
      //           `;

      //     if (prepend) {
      //       eventsList.insertBefore(li, eventsList.firstChild);
      //     } else {
      //       eventsList.appendChild(li);
      //     }

      //     // Animation for new items
      //     li.style.animation = "slideIn 0.3s ease-out";
      //   });

      //   // Limit displayed events to last 50 (prevent DOM bloat)
      //   while (eventsList.children.length > 50) {
      //     const removed = eventsList.lastChild;
      //     displayedEventIds.delete(removed.dataset.id);
      //     eventsList.removeChild(removed);
      //   }
      // }
      function renderEvents(events, prepend = false) {
        // Hide empty state if we have any events (existing + new)
        const totalEvents = eventsList.children.length + events.length;
        if (totalEvents > 0) {
          emptyState.style.display = "none";
          eventsList.style.display = "block";
        }

        events.forEach((event) => {
          // Skip if already displayed (check by ID)
          if (displayedEventIds.has(event.id)) {
            console.log("Skipping duplicate event:", event.id);
            return;
          }
          displayedEventIds.add(event.id);

          const li = document.createElement("li");
          li.className = `event-item event-${event.action.toLowerCase()}`;
          li.dataset.id = event.id;

          const icon = getEventIcon(event.action);

          li.innerHTML = `
            <div class="event-icon">${icon}</div>
            <div class="event-content">
                <p class="event-message">${escapeHtml(event.message)}</p>
                <div class="event-meta">
                    <span class="event-type">${event.action}</span>
                    <span class="event-time">${formatTime(event.timestamp)}</span>
                    <span class="event-id">#${event.request_id}</span>
                </div>
            </div>
        `;

          if (prepend) {
            eventsList.insertBefore(li, eventsList.firstChild);
          } else {
            eventsList.appendChild(li);
          }

          // Animation for new items
          li.style.animation = "slideIn 0.3s ease-out";
        });

        // Update status with correct count
        updateStatus("connected", displayedEventIds.size);

        // Limit displayed events to last 50 (prevent DOM bloat)
        while (eventsList.children.length > 50) {
          const removed = eventsList.lastChild;
          if (removed && removed.dataset.id) {
            displayedEventIds.delete(removed.dataset.id);
          }
          eventsList.removeChild(removed);
        }
      }
      function getEventIcon(action) {
        const icons = {
          PUSH: "â¬†ï¸",
          PULL_REQUEST: "ðŸ”€",
          MERGE: "âœ…",
        };
        return icons[action] || "ðŸ“‹";
      }

      // function updateStatus(status, count = 0) {
      //   statusIndicator.className = "status-indicator " + status;

      //   const now = new Date().toLocaleTimeString();

      //   switch (status) {
      //     case "connected":
      //       statusText.textContent = `Live â€¢ ${count} events`;
      //       lastUpdated.textContent = `Updated: ${now}`;
      //       break;
      //     case "loading":
      //       statusText.textContent = "Updating...";
      //       break;
      //     case "error":
      //       statusText.textContent = "Connection error â€¢ Retrying...";
      //       break;
      //     default:
      //       statusText.textContent = "Connecting...";
      //   }
      // }
      function updateStatus(status, count = 0) {
        statusIndicator.className = "status-indicator " + status;

        const now = new Date().toLocaleTimeString();

        switch (status) {
          case "connected":
            statusText.textContent = `Live â€¢ ${count} event${count !== 1 ? "s" : ""}`;
            lastUpdated.textContent = `Updated: ${now}`;
            break;
          case "loading":
            statusText.textContent = "Updating...";
            break;
          case "error":
            statusText.textContent = "Connection error â€¢ Retrying...";
            break;
          default:
            statusText.textContent = "Connecting...";
        }
      }
      function formatTime(isoString) {
        try {
          const date = new Date(isoString);
          return date.toLocaleString();
        } catch {
          return isoString;
        }
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        stopPolling();
      });
    </script>
  </body>
</html>
